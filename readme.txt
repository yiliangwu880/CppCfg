简介：
	进程通常都有配置文件读取。
	如果配置内容十几行以内，简单。自己写解析代码吧。可能这里工具不合适，流程多了点。
	但是配置内容多而且结构复杂，行数超过几十行。人工编写cpp代码解析配置就麻烦了。
	为了让配置容易编写和cpp代码读取最简单化，因此设计了个辅助工具 CppCfg。
	CppCfg使用步骤：
	）编辑配置文件，配置内容。（格式简单 a=3, b=4. 如果想要复杂的对象参考json结构）
	）导出cpp文件。 内容为解析配置的类。
	）cpp文件加入项目编译
	）启动进程，生成对象。
	
	亮点：
		和利用protobuf,c++解析文本对象类似，但更简单。
		配置文本格式类似json, 但更简单好看，语法格式宽松。
		工具生成cpp类的h文件，用来读取配置。
		cpp代码读取配置静态化。比如: ip = cfg.ip; 而不是 ip=cfg.Get("ip");
		cpp代码配置名和具体配置一样。 而不是像proto的cpp风格。比如 msg.get_ip();
		能简单运算。 比如 num=3+4;
		支持json格式的动态配置。
	
编译方法：
	整个文件夹放到linux目录，安装cmake gcc git等。

	主目录执行：sh clearBuild.sh 完成编译

使用：
	)编译
	）导出配置相关的h文件：
		运行bin目录的export_cpp_cfg执行文件。比如：./export_cpp_cfg ../export_cpp/test_cfg.txt
		成功会生成 CC_test_cfg.h文件
	）你的项目加入导出文件 CC_test_cfg.h,加入com目录的cpp文件。
	）你的项目代码包含 CC_test_cfg.h，初始化配置和读取配置。例子如下：
		test_cfg cfg;			//CC_test_cfg.h里面导出的类
		cfg.LoadFile();			//解析配置文件
		uint64 read = cfg.a1;	//读取配置使用
		
-----------------------------以下详细说明------------------------------------------------------------
目录结构：
	sample			== 使用例子项目
	export_cpp      == 导出工具项目
	test            == 测试用例项目
	bin				== 编译目标文件位置
	com				== 组件，用户自定义项目需要使用里面的源文件。
	vs				== vs浏览代码：执行.\vs\run.bat,生成sln文件

详细介绍：

开发这个工具的原因：
	开发一个服务器，进程几乎都需要读取简单配置启动。
	见过最低效的开发方法：
		）编辑配置文件
		）编辑cpp对应解析代码。  
	    ）cpp文件加入项目编译 
		）启动进程，解析出配置对象。 
		评论：它的明显缺点是手工。写几行配置没问题，写很多配置项那种，每次都要是编写代码，还要查bug,就麻烦了。
		
	protobuf做配置，如下：	
		）编辑配置文件定义对象内容。
		）编辑proto文件定对象结构。
		）导出解析对象的类，为cpp文件。
	    ）cpp文件加入项目编译
		）启动进程，生成对象。 （依赖protobuf库）
		评论：
			自动化不错，可惜对象内容和结构分析编写，效率低。
			依赖protobuf库
			cpp获取对象字段的写法格式难看，特别是数组类型，接口复杂，需要学习成本。
	
	集合以上的优缺点因此设计出CppCfg工具。比较上面那些做法，有特点：
		)配置文件定义对象同时，也定义了结构。
		)工具导出解析配置的cpp类，不用编写代码。
		)不用依赖库，包含导出的h文件就能编译通过。

配置文本格式用类似json，更简化。也支持标准json
	不考虑xml. xml是给机器和程序读的，给人类读写有点反人类。
	不建议标准json. 每个字段名都要强制""符号，繁琐。
	

详细功能：
	读取配置文件
	读取字符串配置
	工具生成cpp类的h文件，用来读取配置。基于linux平台
	静态格式检查
	热更新配置
	可以支持动态格式。动态格式在CPP里面为标准json字符串。
	能简单运算。 右比左优先，比如 10 * 1 + 2 == 30;
	
配置格式：
	综合：
			类型json,C语言命名风格， 比json更简化. 
			对象名不需要双引号。
			直接上例子来说明：
		合法格式：
			//可以不整齐，分隔符很随意
			a=1,
			b:true,	
			c="ab3c" b='a';   //这里是注释，
			aa=[11,22],
			b={
			a=3.3,
			b:"abc",
			}
			b=3

		非法格式
			a=[1,"b"] //数组元素类型必须一致,因为CPP文件要求静态类型
	
	动态格式:
		//用dynamic关键字 声明。 导出到cpp时，b会用json对象呈现给用户使用。
		//数组元素不能有dynamic关键字
		a=1
		dynamic b={ ... } //...内容随意合法格式。 
		b2=[1,2,dynamic {..}] //错误格式，数组元素不能有dynamic关键字
		{ ... } //错误格式,成员名不能匿名
	


		