# 简介：
	进程通常都有配置文件读取。
	如果配置内容十几行以内，格式简单。自己写解析代码吧。这里工具不合适，需要学习成本的。
	但是配置内容多而且结构复杂，比如：数组，嵌套结构体。每次修改，人工编写cpp代码解析配置就繁琐了。
	针对这种情况，设计了个辅助工具 CppCfg，能根据配置内容，导出解析代码。
	CppCfg使用步骤：
	）编辑配置文件，配置内容。（格式简单 a=3, b=4. 如果想要复杂的对象参考json结构）
	）导出cpp文件。 内容为解析配置的类。
	）cpp文件加入项目编译
	）启动进程，生成配置读取对象。
	
	亮点：
		和利用protobuf,c++解析文本对象类似，但更简单。
		配置文本格式类似json, 但更简单好看，语法格式宽松。
		工具生成cpp类的h文件，用来读取配置。
		cpp代码读取配置静态化。比如: ip = cfg.ip; 而不是 ip=cfg.Get("ip");
		cpp代码配置名和具体配置一样。 而不是像proto的cpp风格。比如 msg.get_ip();
		能简单运算。 比如 num=3+4;
		支持json格式的动态配置。（配置对象可以是动态的）
	
	缺点：需要点学习成本。学习配置格式，学习怎么导出cpp解析文件，学习项目引用解析代码。
	
# 编译方法：
	整个文件夹放到linux目录，安装cmake gcc git等。

	主目录执行：sh clearBuild.sh 完成编译

# 使用：
	)编译
	）根据你的项目配置，导出解析的h文件：
		运行bin目录的export_cpp_cfg执行文件。比如：./export_cpp_cfg ../export_cpp/test_cfg.txt 
		成功会生成 test_cfg.h文件
	）你的项目加入导出h文件和com目录的cpp文件。
	）写代码读取配置。例子如下：
		#include "test_cfg.h"
		test_cfg cfg;			//test_cfg.h里面导出的类
		cfg.LoadFile();			//解析配置文件
		uint64 read = cfg.a1;	//读取配置使用
		
    ) 如果多个配置，导出命令例子： ./export_cpp_cfg cfg1.txt cfg2.txt
# -----------------------------以下详细说明------------------------------------------------------------
目录结构：
	sample			== 使用例子项目
	export_cpp      == 导出工具项目
	test            == 测试用例项目
	bin				== 编译目标文件位置
	com				== 组件，用户自定义项目需要使用里面的源文件。
	vs				== vs浏览代码：执行.\vs\run.bat,生成sln文件

详细介绍：

工作机制： 解析类SimpleCfg. 能读取文本配置格式，解析成 标准json对象，用开源库 nlohmann 代码实现的json对象。
          JsToCpp 类，根据标准json对象，生成对象的cppCfg类（读取对象接口静态化，可任意命名）。
          cppCfg类 利用SimpleCfg，能解析匹配的文本配置格式，并初始化。
          用户代码就利用 cppCfg类 读取配置信息。

开发这个工具的原因：
	开发一个服务器，进程几乎都需要读取简单配置启动。
	见过最低效的开发方法：
		）编辑配置文件
		）编辑cpp对应解析代码。  
	    ）cpp文件加入项目编译 
		）启动进程，解析出配置对象。 
		评论：它的明显缺点是手工。编写类似代码。
		
	protobuf做配置，如下：	
		）编辑配置文件定义对象内容。
		）编辑proto文件定对象结构。
		）导出解析对象的类，为cpp文件。
	    ）cpp文件加入项目编译
		）启动进程，生成对象。 （依赖protobuf库）
		评论：
			自动化不错，可惜对象内容和结构分析编写，效率低。
			依赖protobuf库
			cpp获取对象字段的写法格式难看，特别是数组类型，接口复杂，需要学习成本。
	
	集合以上的优缺点因此设计出CppCfg工具。比较上面那些做法，有特点：
		)配置文件定义对象同时，自动隐射出C++类型结构。
		)工具导出解析配置的cpp类，不用编写代码。
		)不用依赖库，包含导出的h文件就能编译通过。

配置文本格式用类似json，更简化。也支持标准json
	不考虑xml. xml太难读了。
	不建议标准json. 每个字段名都要强制""符号，繁琐。

详细功能：
	读取配置文件
	读取字符串配置
	工具生成cpp类的h文件，用来读取配置。基于linux平台
	静态格式检查
	热更新配置
	可以支持动态格式。动态格式在CPP里面为标准json字符串。
	能简单运算。 右比左优先，比如 10 * 1 + 2 == 30;
	
配置格式：
	综合：
			类似json,C语言命名风格， 比json更简化. 
			对象名不需要双引号。
			直接上例子来说明：
		合法格式：
			//可以不整齐，分隔符很随意
			a=1,
			b:true,	
			c="ab3c" b='a';   //这里是注释，
			aa=[11,22],
			b={
			a=3.3,
			b:"abc",
			}
			b=0xf3

		非法格式
			a=[1,"b"] //数组元素类型必须一致,因为CPP文件要求静态类型
			a=
			{
				b=1;
			}
	
	动态格式:
		//用dynamic关键字 声明。 导出到cpp时，b会用json对象呈现给用户使用。
		//数组元素不能有dynamic关键字
		a=1
		dynamic b={ ... } //...内容随意合法格式。 
		b2=[1,2,dynamic {..}] //错误格式，数组元素不能有dynamic关键字
		{ ... } //错误格式,成员名不能匿名
	


		